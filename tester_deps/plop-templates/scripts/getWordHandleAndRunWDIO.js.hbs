const ffi = require('ffi-napi');
const ref = require('ref-napi');
const { spawn } = require('child_process');
const which = require('which');  // To dynamically resolve the path of npx

// Load user32.dll and define Windows API functions
const user32 = ffi.Library('user32', {
  'EnumWindows': ['bool', ['pointer', 'int32']],
  'GetClassNameW': ['int32', ['int32', 'pointer', 'int32']],
  'IsWindowVisible': ['bool', ['int32']],
  'GetWindowThreadProcessId': ['uint32', ['int32', 'uint32*']]  // Retrieves the process ID associated with a window
});

// Mapping class names and process names for Word, Excel, and PowerPoint
const appInfo = {
  Word: { process: 'winword', className: 'OpusApp' },
  Excel: { process: 'excel', className: 'XLMAIN' },
  PowerPoint: { process: 'powerpnt', className: 'PPTFrameClass' }
};

// Function to convert a JavaScript string to a UTF-16 wide string buffer
function toWideString(str) {
  return Buffer.from(str + '\0', 'ucs2');
}

// Function to enumerate all windows and find the application's window by class name
function getAppWindowHandle(className) {
  let hwnd = 0;
  const classNameBuffer = Buffer.alloc(256); // Buffer to hold the window class name

  const enumWindowsProc = ffi.Callback('bool', ['int32', 'int32'], (hwndCurrent, lParam) => {
    user32.GetClassNameW(hwndCurrent, classNameBuffer, 256);
    const currentClassName = ref.reinterpretUntilZeros(classNameBuffer, 2).toString('ucs2');

    if (currentClassName === className && user32.IsWindowVisible(hwndCurrent)) {
      hwnd = hwndCurrent;
      return false;  // Stop enumerating once we find the window
    }
    return true;  // Continue enumeration
  });

  user32.EnumWindows(enumWindowsProc, 0);

  if (hwnd === 0) {
    console.error('The application is not running or cannot find the window.');
    process.exit(1);
  }

  return '0x' + hwnd.toString(16).toUpperCase();
}

// Function to launch the selected application (Word, Excel, PowerPoint)
function launchApp(processName) {
  return new Promise((resolve, reject) => {
    const appProcess = spawn('cmd', ['/c', 'start', processName]);  // Launch the selected application

    appProcess.on('error', (err) => {
      console.error(`Failed to launch ${processName}:`, err);
      reject(err);
    });

    appProcess.on('close', (code) => {
      if (code !== 0) {
        reject(`${processName} process exited with code ${code}`);
      } else {
        console.log(`${processName} launched successfully.`);
        resolve();
      }
    });
  });
}

// Function to get the Process ID (PID) of the window
function getProcessIdFromWindowHandle(hwnd) {
  const pidBuffer = ref.alloc('uint32');  // Allocate space for the PID
  user32.GetWindowThreadProcessId(hwnd, pidBuffer);  // Get the PID
  const pid = pidBuffer.deref();  // Dereference the buffer to get the PID value
  return pid;
}

// Prompt user to select the application they want to launch using dynamic import
async function promptForApp() {
  const { default: inquirer } = await import('inquirer');  // Accessing the default export explicitly
  return inquirer.prompt([
    {
      type: 'list',
      name: 'app',
      message: 'Which application would you like to launch?',
      choices: ['Word', 'Excel', 'PowerPoint']
    }
  ]);
}

// Function to run WebDriverIO with the NativeWindowHandle and show output in real-time
function runWebDriverIOWithHandle(hwnd) {
  console.log('Launching WebDriverIO test runner...');
  // Find the full path to npx
  which('npx', (err, npxPath) => {
    if (err) {
      console.error('Unable to find npx:', err);
      process.exit(1);
    }

    // Run the WebDriverIO command using the full path to npx
    const wdioProcess = spawn(npxPath, ['yarn', 'wdio', 'wdio.win32.conf.ts', 'nativeWindowHandle', hwnd], {
      stdio: 'inherit'  // This passes the parent's stdio to the child process to preserve colors
    });

    wdioProcess.on('close', (code) => {
      if (code !== 0) {
        console.error(`WebDriverIO process exited with code ${code}`);
      } else {
        console.log('WebDriverIO process completed successfully');
        // Shut down Microsoft Word after testing completes using the process ID (PID)
        const pid = getProcessIdFromWindowHandle(hwnd);
        shutdownAppByPid(pid);
      }
    });
  });
}

// Function to shut down the specific application by its PID
function shutdownAppByPid(pid, appName) {
  return new Promise((resolve, reject) => {
    // Kill the process by PID
    const killProcess = spawn('taskkill', ['/F', '/PID', pid]);

    killProcess.stdout.on('data', (data) => {
      console.log(`Shutdown output: ${data}`);
    });

    killProcess.stderr.on('data', (data) => {
      console.error(`Shutdown error: ${data}`);
    });

    killProcess.on('close', (code) => {
      if (code !== 0) {
        reject(`Failed to shut down ${appName}, taskkill exited with code ${code}`);
      } else {
        console.log(`${appName} shut down successfully.`);
        resolve();
      }
    });
  });
}

// Immediately Invoked Async Function Expression (to use await at the top level)
(async function () {
  try {
    // Prompt the user for their choice of application
    const { app } = await promptForApp();
    const { process: processName, className } = appInfo[app];

    // Launch the selected application (Word, Excel, PowerPoint)
    await launchApp(processName);

    // Wait for a short while to ensure Word is fully launched (optional: adjust delay if needed)
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Find the application's window handle after launching
    const hwnd = getAppWindowHandle(className);
    console.log(`Found ${app} window handle: ${hwnd}`);

    // Run WebDriverIO with the retrieved window handle
    runWebDriverIOWithHandle(hwnd);
  } catch (error) {
    console.error('Error during the process:', error);
  }
})();
